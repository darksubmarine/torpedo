In the context of hexagonal architecture, an entity service is a component that encapsulates business logic related to a specific domain entity. It provides methods to manipulate and query the entity, often coordinating between various input and output ports to perform complex operations.

### Role of an Entity Service

1. **Encapsulation**: It encapsulates the business logic associated with a specific domain entity.
2. **Coordination**: It coordinates between different input ports (such as user requests) and output ports (such as databases or other services).
3. **Abstraction**: It abstracts the complex operations related to the entity, providing a clear and cohesive interface for use cases.
4. **Reusability**: It promotes reusability by isolating entity-specific logic that can be used across different use cases.

### Components of an Entity Service

1. **Entity**: The domain model representing the data and behavior of a business object.
2. **Repository Interface (Output Port)**: Defines methods for persisting and retrieving the entity.
3. **Service Interface (Input Port)**: Defines methods for performing business operations on the entity.
4. **Service Implementation**: Implements the business logic defined in the service interface.
5. **Adapters**: Implementations of input and output ports to connect the service with external systems.

### Benefits of an Entity Service

1. **Centralized Logic**: Consolidates business logic related to a specific entity in one place.
2. **Reusability**: Promotes reusability across different use cases and delivery mechanisms.
3. **Maintainability**: Improves maintainability by isolating entity-specific logic.
4. **Testability**: Enhances testability by decoupling business logic from external dependencies.

In hexagonal architecture, an entity service plays a crucial role in managing the business logic associated with a specific domain entity. By encapsulating this logic and providing clear interfaces for interaction, the entity service ensures that the core application remains flexible, maintainable, and testable. This separation of concerns aligns with the principles of hexagonal architecture, promoting a clean and adaptable application design.

!!! info "Service at Entity layer"
    The service at the entity layer involves all the business logic stronger linked with the entity itself. 
    If you have business logic that requires use more than one entity, please read [Use Case](basic_usecase_definition.html) or [Domain Service](basic_domain_service.html) 


## Torpedo service implementation

As we said before a Service is where the application contains the business logic. A service has as main dependency a `Repository` object and knows how to handle its `Entity` model. 
Additionally, a Service `port` is provided as interface named `IService` on this way the service can interact with any input adapter.

Basically each time that Torpedo generates the code two classes are written. A `Service` class and a `ServiceBase` class.
The last one will contain the CRUD operations, the Query operation and the needed autogenerated code.


!!! danger "As developer"

    As a developer your own business logic **MUST BE** written into the Service class in order to avoid
    that Torpedo code generation tool overwrite your code!
    
    We strongly recommend write your uses cases into the Service class and not as part of the ServiceBase. 
    Or even better, please read [Use Case](basic_usecase_definition.html).

The diagram below illustrates how the classes are generated:

``` mermaid
classDiagram
  ServiceBase <|-- Service
  ServiceBase : IRepository repo
  
  ServiceBase: +Create(Entity entity) Entity
  ServiceBase: +Read(String id) Entity
  ServiceBase: +Update(Entity entity) Entity
  ServiceBase: +Delete(String id)
  ServiceBase: +Query(q tql.Query) Result
  
```
