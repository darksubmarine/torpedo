// Code generated by TORPEDO DO NOT EDIT.

// Package redis_mongodb is an output adapter to store entities into mongodb with redis as cache layer
package redis_mongodb

import (
	"{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}"
	mongoOutput "{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}/outputs/mongodb"
	redisOutput "{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}/outputs/redis"
	"errors"
	"fmt"
	torpedo_lib "github.com/darksubmarine/torpedo-lib-go"
	"github.com/darksubmarine/torpedo-lib-go/tql"
	"github.com/go-redis/redis/v8"
	"go.mongodb.org/mongo-driver/mongo"
)

// redisMongoRepositoryBase Redis+Mongo output repository.
// Custom repository logic should be placed here.
type redisMongoRepositoryBase struct {
	redisRepo {{.PackageName}}.IRepository
	mongoRepo {{.PackageName}}.IRepository
}

// NewRedisMongoRepositoryBase repository constructor
func newRedisMongoRepositoryBase(client *redis.Client, collection *mongo.Collection, cryptoKey []byte) *redisMongoRepositoryBase {
	return &redisMongoRepositoryBase{
		redisRepo: redisOutput.NewRedisRepository(client, cryptoKey),
		mongoRepo: mongoOutput.NewMongoDBRepository(collection, cryptoKey),
	}
}

// newRedisMongoRepositoryBaseWithHooks repository constructor with mongodb hooks
func newRedisMongoRepositoryBaseWithHooks(client *redis.Client, collection *mongo.Collection, cryptoKey []byte, hooks *mongoOutput.HookBuilder) *redisMongoRepositoryBase {
	return &redisMongoRepositoryBase{
		redisRepo: redisOutput.NewRedisRepository(client, cryptoKey),
		mongoRepo: mongoOutput.NewMongoDBRepositoryWithHooks(collection, cryptoKey, hooks),
	}
}

// Save adds the entity in Redis cache and MongoDB
func (r *redisMongoRepositoryBase) Save(entity *{{.PackageName}}.{{.EntityName}}) error {

	if err := r.mongoRepo.Save(entity); err != nil {
		return fmt.Errorf("%w %s", ErrorSavingOnMongoDB, err)
	} else {
		if err := r.redisRepo.Save(entity); err != nil {
			return fmt.Errorf("%w %s", ErrSavingOnCache, err)
		}
	}

	return nil
}

// FetchByID fetch entity by ID. First try to fetch it from redis cache and if it is not found try from mongodb
func (r *redisMongoRepositoryBase) FetchByID(id string) (*{{.PackageName}}.{{.EntityName}}, error) {

	if entityFromRedis, err := r.redisRepo.FetchByID(id); err != nil {

		if errors.Is(err, torpedo_lib.ErrIdNotFound) {
			if entityFromMongo, err := r.mongoRepo.FetchByID(id); err != nil {
				return nil, err
			} else {
				_ = r.redisRepo.Update(entityFromMongo) // if object is not in redis, save it!
				return entityFromMongo, nil
			}
		}
		return nil, err
	} else {
		return entityFromRedis, nil
	}
}

// Update updates the stored entity in redis and mongodb
func (r *redisMongoRepositoryBase) Update(entity *{{.PackageName}}.{{.EntityName}}) error {
	if err := r.mongoRepo.Update(entity); err != nil {
		return fmt.Errorf("%w %s", ErrorSavingOnMongoDB, err)
	} else {
		if err := r.redisRepo.Update(entity); err != nil {
			return fmt.Errorf("%w %s", ErrSavingOnCache, err)
		}
	}

	return nil
}

// DeleteByID removes the entity with the given ID. First try to remove it from mongodb (source of truth) and next from Redis cache
func (r *redisMongoRepositoryBase) DeleteByID(id string) error {
	if err := r.mongoRepo.DeleteByID(id); err != nil {
		return fmt.Errorf("%w %s", ErrorDeletingOnMongoDB, err)
	} else {
		if err := r.redisRepo.DeleteByID(id); err != nil {
			if errors.Is(err, torpedo_lib.ErrIdNotFound) {
				return nil // no error because we are removing entity and was already deleted from Redis, maybe by TTL
			}
			return fmt.Errorf("%w %s", ErrDeletingOnCache, err)
		}
	}
	return nil
}

{{if .HasRelationshipsBelongsTo}}
{{range .FetchRelationshipsBelongsTo}}
// DeleteBy{{ .Ref.Name | ToTitle }} removes the entity by {{ .Ref.Name }}Id
func (r *redisMongoRepositoryBase) DeleteBy{{ .Ref.Name | ToTitle }}({{ .Ref.Name }}Id string) error {

	if err := r.mongoRepo.DeleteBy{{ .Ref.Name | ToTitle }}({{ .Ref.Name }}Id); err != nil {
		return fmt.Errorf("%w %s", ErrorDeletingOnMongoDB, err)
	}

	// TODO remove from REDIS if not this is a consistency issue
	//return ErrDeletingOnCache

	return nil
}
{{end}}{{end}}

// Query Torpedo Query Language is calling directly to mongodb repository due to redis doesn't support it
func (r *redisMongoRepositoryBase) Query(q *tql.Query, metadata map[string]string) ([]*{{.PackageName}}.{{.EntityName}}, error) {
	return r.mongoRepo.Query(q, metadata)
}
