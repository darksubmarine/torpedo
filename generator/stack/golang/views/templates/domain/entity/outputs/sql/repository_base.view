// Code generated by TORPEDO DO NOT EDIT.

// Package sql is an output adapter to store entities in relational databases
package sql

import (
	"{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}"
	"database/sql"
	"errors"
	"fmt"
	torpedo_lib "github.com/darksubmarine/torpedo-lib-go"
	"github.com/darksubmarine/torpedo-lib-go/storage/sql_utils"
	"github.com/darksubmarine/torpedo-lib-go/tql"
	"github.com/jmoiron/sqlx"
	"strings"
)

// sqlRepositoryBase SQL repository implements {{.PackageName}}.IRepositoryBase
type sqlRepositoryBase struct {
	db   *sqlx.DB
	ckey []byte
}

// newSqlRepositoryBase repository constructor
func newSqlRepositoryBase(db *sql.DB, driverName string, cryptoKey []byte) *sqlRepositoryBase {
	dbx := sqlx.NewDb(db, driverName)
	return &sqlRepositoryBase{db: dbx, ckey: cryptoKey}
}

// Save the entity into the repository collection
func (r *sqlRepositoryBase) Save(entity *{{.PackageName}}.{{.EntityName}}) error {
	dmo, err := NewEntityDMOSqlFrom(entity, r.ckey)
	if err != nil {
		return err
	}

	insertStm := sql_utils.InsertStatementFromDMO(r.db.DriverName(),TableName, dmo, entity.FieldsMetadata())

	if _, err := r.db.NamedExec(insertStm, dmo); err != nil {
		return err
	}

	return nil
}

// FetchByID fetch entity by ID
func (r *sqlRepositoryBase) FetchByID(id string) (*{{.PackageName}}.{{.EntityName}}, error) {

	var dmo = NewEntityDMOSql(r.ckey)

	if err := r.db.Get(dmo, r.db.Rebind(fmt.Sprintf({{backQuote}}SELECT * FROM %s WHERE id = ?{{backQuote}}, TableName)), id); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, torpedo_lib.ErrIdNotFound
		}
		return nil, err
	}

	entity, err := dmo.ToEntity()
	if err != nil {
		return nil, err
	}
	return entity, nil
}

// Update updates the stored entity
func (r *sqlRepositoryBase) Update(entity *{{.PackageName}}.{{.EntityName}}) error {
	dmo, err := NewEntityDMOSqlFrom(entity, r.ckey)
	if err != nil {
		return err
	}

	updateStm := sql_utils.UpdateStatementFromDMO(r.db.DriverName(), TableName, dmo, entity.FieldsMetadata())

	if _, err := r.db.NamedExec(updateStm, dmo); err != nil {
		return err
	}

	return nil
}

// DeleteByID removes the entity with the given ID from the collection
func (r *sqlRepositoryBase) DeleteByID(id string) error {

	if res, err := r.db.Exec(r.db.Rebind(fmt.Sprintf({{backQuote}}DELETE FROM %s WHERE id = ?{{backQuote}}, TableName)), id); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return torpedo_lib.ErrIdNotFound
		}
		return err
	} else {
		if rows, err := res.RowsAffected(); err != nil {
			return err
		} else if rows == 0 {
			return torpedo_lib.ErrIdNotFound
		}
	}

	return nil
}

{{if .HasRelationshipsBelongsTo}}
{{range .FetchRelationshipsBelongsTo}}
// DeleteBy{{ .Ref.Name | ToTitle }} removes the entity by {{ .Ref.Name }}Id
func (r *sqlRepositoryBase) DeleteBy{{ .Ref.Name | ToTitle }}({{ .Ref.Name }}Id string) error {

	if res, err := r.db.Exec(r.db.Rebind(fmt.Sprintf({{backQuote}}DELETE FROM %s WHERE {{ .Ref.Name }}Id = ?{{backQuote}}, TableName)), {{ .Ref.Name }}Id); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return torpedo_lib.ErrIdNotFound
		}
		return err
	} else {
		if rows, err := res.RowsAffected(); err != nil {
			return err
		} else if rows == 0 {
			return torpedo_lib.ErrIdNotFound
		}
	}

	return nil

}
{{end}}{{end}}

// Query maps the given TQL to a SQL query and execute it
func (r *sqlRepositoryBase) Query(q *tql.Query, metadata map[string]string) ([]*{{.PackageName}}.{{.EntityName}}, error) {

	filter, values, err := tql.MapToSQLFilter(q, metadata)
	if err != nil {
		return nil, err
	}

	query := strings.Builder{}
	if q.HasPagination() {
		if q.IsOffsetPagination() {
			query.WriteString(fmt.Sprintf("SELECT * FROM %s WHERE %s", TableName, filter))
			if q.HasSort() {
				query.WriteString(tql.ToSortSQL(q.OffsetPaginationSort()))
			}
			query.WriteString(fmt.Sprintf(" LIMIT %d", q.PaginationItems()))
			query.WriteString(fmt.Sprintf(" OFFSET %d", q.PaginationOffset()))
		} else if q.IsCursorPagination() {
			sqlWhere, sqlLimit, sqlOrder := tql.CursorToSQL(q, filter)
			query.WriteString(fmt.Sprintf("SELECT * FROM %s %s %s LIMIT %d", TableName, sqlWhere, sqlOrder, sqlLimit))
		}
	} else {
		query.WriteString(fmt.Sprintf("SELECT * FROM %s WHERE %s", TableName, filter))
	}

	// Execute query
	if rows, err := r.db.NamedQuery(query.String(), values); err != nil {
		return nil, err
	} else {
		toRet := make([]*{{.PackageName}}.{{.EntityName}}, 0)
		for rows.Next() {
			dmo := NewEntityDMOSql(r.ckey)
			if err := rows.StructScan(dmo); err != nil {
				return nil, err
			}

			if entity, err := dmo.ToEntity(); err != nil {
				return nil, err
			} else {
				toRet = append(toRet, entity)
			}
		}
		return toRet, nil
	}
}
