// Code generated by TORPEDO DO NOT EDIT.

// Package mongodb is an output adapter to store entities in MongoDB
package mongodb

import (
	"{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}"
	"context"
	"errors"
	torpedo_lib "github.com/darksubmarine/torpedo-lib-go"
	"github.com/darksubmarine/torpedo-lib-go/tql"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// mongoDBRepositoryBase MongoDB repository implements {{.PackageName}}.IRepositoryBase
type mongoDBRepositoryBase struct {
	collection *mongo.Collection
	ckey       []byte
	hooks *HookBuilder
}

// newMongoDBRepositoryBase repository constructor
func newMongoDBRepositoryBase(collection *mongo.Collection, cryptoKey []byte) *mongoDBRepositoryBase {
		return newMongoDBRepositoryBaseWithHooks(collection, cryptoKey, nil)
}

// newMongoDBRepositoryBaseWithHooks repository constructor with hooks
func newMongoDBRepositoryBaseWithHooks(collection *mongo.Collection, cryptoKey []byte, hooks *HookBuilder) *mongoDBRepositoryBase {
	if hooks == nil {
		return &mongoDBRepositoryBase{collection: collection, ckey: cryptoKey, hooks:NewHookBuilder(nil)}
	}
	return &mongoDBRepositoryBase{collection: collection, ckey: cryptoKey, hooks:hooks}
}


// Save the entity into the repository collection
func (r *mongoDBRepositoryBase) Save(entity *{{.PackageName}}.{{.EntityName}}) error {
	dmo, err := NewEntityDMOMongoDBFrom(entity, r.ckey)
	if err != nil {
		return err
	}

	h := r.hooks.Save()
	h.BeforeSave(dmo)
	_, err = r.collection.InsertOne(context.Background(), dmo)
	h.AfterSave(dmo,err)
	return err
}

// FetchByID fetch entity by ID
func (r *mongoDBRepositoryBase) FetchByID(id string) (*{{.PackageName}}.{{.EntityName}}, error) {
	h := r.hooks.FetchById()
	h.BeforeFetchById(id)
	filter := bson.D{{"{{"}}"_id", id}}
	res := r.collection.FindOne(context.TODO(), filter)
	dmo := NewEntityDMOMongoDB(r.ckey)
	if err := res.Decode(dmo); err != nil {
		h.AfterFetchById(nil, err)
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, torpedo_lib.ErrIdNotFound
		}
		return nil, err
	}

	entity, err := dmo.ToEntity()
	if err != nil {
		h.AfterFetchById(dmo, err)
		return nil, err
	}

	h.AfterFetchById(dmo, nil)
	return entity, nil
}

// Update updates the stored entity
func (r *mongoDBRepositoryBase) Update(entity *{{.PackageName}}.{{.EntityName}}) error {

	id := entity.Id()
	if id == "" {
		return torpedo_lib.ErrEmptyId
	}

	dmo, err := NewEntityDMOMongoDBFrom(entity, r.ckey)
	if err != nil {
		return err
	}
	update := dmo.updateDocument(entity.FieldsMetadata())

	h := r.hooks.Update()
	h.BeforeUpdate(dmo)
	_, err = r.collection.UpdateByID(context.Background(), id, update)
	h.AfterUpdate(dmo,err)
	return err
}

// DeleteByID removes the entity with the given ID from the collection
func (r *mongoDBRepositoryBase) DeleteByID(id string) error {
	filter := bson.D{{"{{"}}"_id", id}}

	h := r.hooks.DeleteById()
	h.BeforeDeleteById(id)
	res, err := r.collection.DeleteOne(context.Background(), filter)
	if err != nil {
		h.AfterDeleteById(err)
		return err
	}

	if res.DeletedCount == 0 {
		h.AfterDeleteById(torpedo_lib.ErrIdNotFound)
		return torpedo_lib.ErrIdNotFound
	}

	h.AfterDeleteById(nil)
	return nil
}

{{if .HasRelationshipsBelongsTo}}
{{range .FetchRelationshipsBelongsTo}}
// DeleteBy{{ .Ref.Name | ToTitle }} removes the entity by {{ .Ref.Name }}Id
func (r *mongoDBRepositoryBase) DeleteBy{{ .Ref.Name | ToTitle }}({{ .Ref.Name }}Id string) error {
	filter := bson.D{{"{{"}}"{{.Ref.Name}}Id", {{- .Ref.Name }}Id}}
	h := r.hooks.DeleteBy()
	h.BeforeDeleteBy("{{.Ref.Name}}", {{- .Ref.Name }}Id)
	res, err := r.collection.DeleteMany(context.Background(), filter)
	if res != nil {
		h.AfterDeleteBy(res.DeletedCount, err)
	} else {
		h.AfterDeleteBy(0, err)
	}
	return err
}
{{end}}{{end}}

// Query maps the given TQL to a MongoDB query and execute it
func (r *mongoDBRepositoryBase) Query(q *tql.Query, metadata map[string]string) ([]*{{.PackageName}}.{{.EntityName}}, error) {

	h := r.hooks.Query()
	h.BeforeQuery(q)

// TODO the mapping between the entity field name and the DMO can be handled by tags into the DMO
// type DMO struct {
// 		MyCustomField 'bson:"custom" etyMapTo:"customField"'
// }
	//dmo := NewEntityDMOMongoDB([]byte("invalid"))
	//metadata_ := tql.ToMongoDBMetadata(dmo)
	//filter, err := tql.MapToMongoDBFilter(q, metadata_)

	filter, err := tql.MapToMongoDBFilter(q, metadata)
	if err != nil {
		return nil, err
	}

	opts := options.Find()

	if q.HasPagination() {
		if q.IsOffsetPagination() {
			opts.SetSkip(q.PaginationOffset())
			opts.SetLimit(q.PaginationItems())
			if q.HasSort() {
				opts.SetSort(tql.ToSortDocument(q.OffsetPaginationSort()))
			}
		} else if q.IsCursorPagination() {
			curFilter, limit, sortD := tql.CursorToDocument(q, filter)
			filter = curFilter
			opts.SetLimit(limit)
			opts.SetSort(sortD)
		}
	}

	// TODO pass context as parameter
	cursor, err := r.collection.Find(context.TODO(), filter, opts)
	if err != nil {
		h.AfterQuery(err)
		return nil, err
	}

	toRet := []*{{.PackageName}}.{{.EntityName}}{}
	for cursor.Next(context.TODO()) {

		dmo := NewEntityDMOMongoDB(r.ckey)
		if err := cursor.Decode(dmo); err != nil {
			h.AfterQuery(err)
			return nil, err
		}

		if entity, err := dmo.ToEntity(); err != nil {
			h.AfterQuery(err)
			return nil, err
		} else {
			toRet = append(toRet, entity)
		}
	}

	h.AfterQuery(nil)
	return toRet, nil
}
