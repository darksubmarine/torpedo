// Code generated by TORPEDO DO NOT EDIT.

// Package gin input
package gin

import (
	"{{ .Meta.Package }}{{ .Meta.EntityPath }}/{{.PackageName}}"
	"github.com/darksubmarine/torpedo-lib-go/entity"

{{if .HasNestedLoading }}
	{{range .FetchNestedLoading}}
		{{ .Ref.Name }}HTTP "{{ $.Meta.Package }}{{ $.Meta.EntityPath }}/{{.Ref.PackageName}}/inputs/http/gin"
{{end}}{{end}}

)

var optionalFields = []string{
{{range .Schema.Fields}}
{{if .IsOptional }}"{{ .Name | ToTitle }}_",{{end}}
{{end}}
}

func init() {
    mt := {{.PackageName}}.FieldsMetadata()
	for fName, v := range mt {
		if v.IsOptional() {
			fieldName := v.DtoHttpName()
			if fieldName == "" {
				fieldName = entity.FieldNameToCode(fName)
			}
			optionalFields = append(optionalFields, fieldName)
		}
	}
}


// PartialDTO partial data transfer object schema
type PartialDTO struct {
	ReadOnlyDTO
	WriteableDTO
	CustomDTO
}//@name {{.PackageName}}.PartialDTO

// UpdatableDTO accept only the writable fields (not read only)
type UpdatableDTO struct {
	WriteableDTO
	CustomDTO
}//@name {{.PackageName}}.UpdatableDTO

// MetadataDTO the metadata fields like id, create and update.
type MetadataDTO struct {
	Id_      *string {{backQuote}}json:"id"{{backQuote}}
	Created_ *int64  {{backQuote}}json:"created"{{backQuote}}
	Updated_ *int64  {{backQuote}}json:"updated"{{backQuote}}
}//@name {{.PackageName}}.MetadataDTO

// ReadOnlyDTO defines the read only fields
type ReadOnlyDTO struct {
	{{range .Schema.Fields}}{{if .ReadOnly }}
	{{ .Name | ToTitle }}_	*{{ .FieldType }} {{backQuote}}json:"{{ fromInputFieldsMap .Name $.Adapters.Input.Http.FieldMap }},omitempty"{{backQuote}}{{end}}{{end}}
}//@name {{.PackageName}}.ReadOnlyDTO

// WriteableDTO defines the writable fields
type WriteableDTO struct {
	{{range .Schema.Fields}}{{if .ReadOnly | not }}
	{{ .Name | ToTitle }}_	*{{ .FieldType }} {{backQuote}}json:"{{ fromInputFieldsMap .Name $.Adapters.Input.Http.FieldMap }},omitempty"{{backQuote}}{{end}}{{end}}
}//@name {{.PackageName}}.WriteableDTO


type RelationshipsDTO struct {
{{if .HasNestedLoading }}
	{{range .FetchNestedLoading}}{{if isHasOne .Cardinality }} // hasOne
	    {{.Ref.Name | ToTitle}}_ *{{ .Ref.Name }}HTTP.FullDTO {{backQuote}}json:"{{ .Ref.Name}},omitempty"{{backQuote}}
	{{else}} // hasMany
		{{.Ref.PluralName | ToTitle}}_ []{{ .Ref.Name }}HTTP.FullDTO {{backQuote}}json:"{{ .Ref.PluralName}},omitempty"{{backQuote}}
	{{end}}{{end}}
{{end}}
}//@name {{.PackageName}}.RelationshipsDTO


// FullDTO adds the framework fields id, created and updated to complete the schema.
// Implements {{.PackageName}}.IEntityDTO
type FullDTO struct {
	MetadataDTO
	ReadOnlyDTO
	WriteableDTO
	RelationshipsDTO
	CustomDTO
}//@name {{.PackageName}}.FullDTO

// NewFullDTO full DTO constructor
func NewFullDTO() *FullDTO {
	return new(FullDTO)
}

// Id getter method
func (dto *FullDTO) Id() string { return *dto.Id_ }

// Created getter method
func (dto *FullDTO) Created() int64 { return *dto.Created_ }

// Updated getter method
func (dto *FullDTO) Updated() int64 { return *dto.Updated_ }


{{range .Schema.Fields}}
// {{ .Name | ToTitle }} getter method
func (dto *FullDTO) {{ .Name | ToTitle }}() {{ .FieldType }} { return *dto.{{ .Name | ToTitle }}_ }
{{end}}



func FromEntity(ety *{{.PackageName}}.{{.EntityName}}) (*FullDTO, error) {
	dto := NewFullDTO()
	if err := entity.To(ety, dto); err != nil {
		return nil, err
	}

	{{if .HasNestedLoading }}{{range .FetchNestedLoading}}
		if err := convertLoaded{{ .Ref.Name | ToTitle}}(ety, dto); err != nil {
			return nil, err
		}
	{{end}}{{end}}

	return dto, nil
}

{{if .HasNestedLoading }}{{range .FetchNestedLoading}}
func convertLoaded{{ .Ref.Name | ToTitle}}(ety *{{$.PackageName}}.{{$.EntityName}}, dto *FullDTO) error {

{{if isHasOne .Cardinality }} // hasOne

	oETY := ety.{{.Ref.Name | ToTitle}}()
	if oDTO, err := {{ .Ref.Name }}HTTP.FromEntity(oETY); err == nil {
        dto.{{.Ref.Name | ToTitle}}_ = oDTO
    } else {
        return err
    }

{{else}} // hasMany

	{{.Ref.PluralName}} := make([]{{ .Ref.Name }}HTTP.FullDTO, len(ety.{{.Ref.PluralName | ToTitle}}()))
	for i, oETY := range ety.{{.Ref.PluralName | ToTitle}}() {
		if oDTO, err := {{ .Ref.Name }}HTTP.FromEntity(oETY); err == nil {
			{{.Ref.PluralName}}[i] = *oDTO
		} else {
			return err
		}
	}

	dto.{{.Ref.PluralName | ToTitle}}_ = {{.Ref.PluralName}}
{{end}}

	return nil
}


{{end}}{{end}}
